# Инструкция для ИИ: Проверка кода NodeJS на соответствие стандартам

## Цель
Проверить написанный разработчиком NodeJS код на соответствие общепринятым стандартам языка и предоставить детальный отчет с рекомендациями по исправлению, но **НЕ вносить изменения автоматически**.

## Общие принципы работы

1. **Анализировать, не изменять**: Только выявлять проблемы и предлагать решения
2. **Запрашивать согласие**: Перед любыми изменениями получить явное разрешение от пользователя
3. **Приоритизация**: Указывать критичность каждого найденного несоответствия (критичная, важная, рекомендация)
4. **Конструктивность**: Всегда предлагать конкретные способы исправления с примерами

---

## Стандарты и правила проверки

### 1. СТРУКТУРА И ОРГАНИЗАЦИЯ КОДА

#### 1.1 Структура модулей
**Проверить:**
- Импорты организованы в правильном порядке:
  1. Встроенные модули Node.js (fs, path, http)
  2. Внешние зависимости (express, lodash)
  3. Внутренние модули приложения
  4. Локальные импорты из текущей директории

**Тест:**
```javascript
// ❌ Неправильно
const express = require('express');
const fs = require('fs');
const myModule = require('./myModule');
const lodash = require('lodash');

// ✅ Правильно
const fs = require('fs');
const path = require('path');

const express = require('express');
const lodash = require('lodash');

const myModule = require('./myModule');
const helper = require('./helper');
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать на несоответствие и предложить правильный порядок импортов.

---

#### 1.2 Экспорт модулей
**Проверить:**
- Используется ли современный синтаксис (`module.exports` или ES6 `export`)
- Экспорты находятся в конце файла
- Один главный экспорт на файл (предпочтительно)

**Тест:**
```javascript
// ❌ Избегать множественных exports в разных местах
exports.foo = function() {};
// ... код ...
exports.bar = function() {};

// ✅ Предпочтительно
function foo() {}
function bar() {}

module.exports = {
  foo,
  bar
};
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать на проблему, объяснить преимущества единого экспорта в конце файла.

---

### 2. ИМЕНОВАНИЕ

#### 2.1 Переменные и функции
**Проверить:**
- `camelCase` для переменных и функций
- `PascalCase` для классов и конструкторов
- `UPPER_SNAKE_CASE` для констант (глобальных неизменяемых значений)
- Описательные имена (избегать `a`, `b`, `temp`, `data` без контекста)

**Тест:**
```javascript
// ❌ Неправильно
const MyVariable = 'test';  // Должно быть camelCase
function Do_Something() {}  // Должно быть camelCase
const apikey = 'secret';    // Константа должна быть UPPER_SNAKE_CASE
let x = [];                 // Неописательное имя

// ✅ Правильно
const myVariable = 'test';
function doSomething() {}
const API_KEY = 'secret';
const MAX_CONNECTION_TIMEOUT = 5000;
let userList = [];
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать конкретные переменные/функции с некорректными именами и предложить правильные варианты.

---

#### 2.2 Имена файлов
**Проверить:**
- `kebab-case` или `camelCase` для обычных файлов
- `PascalCase` для файлов, содержащих классы
- Описательные имена файлов

**Тест:**
```javascript
// ❌ Неправильно
User_Controller.js
my_helper.js

// ✅ Правильно
user-controller.js  или  userController.js
my-helper.js        или  myHelper.js
UserModel.js        (для класса)
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать файлы с неправильными именами и предложить переименование.

---

### 3. СИНТАКСИС И СОВРЕМЕННЫЕ ВОЗМОЖНОСТИ

#### 3.1 Использование const/let вместо var
**Проверить:**
- Не используется `var`
- Используется `const` для неизменяемых ссылок
- Используется `let` для изменяемых переменных

**Тест:**
```javascript
// ❌ Неправильно
var name = 'John';
var age = 30;
age = 31;

// ✅ Правильно
const name = 'John';
let age = 30;
age = 31;
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать каждое использование `var`, объяснить проблемы с областью видимости и предложить замену на `const/let`.

---

#### 3.2 Стрелочные функции
**Проверить:**
- Использование стрелочных функций для коллбэков
- Правильное использование `this` (стрелочные функции не имеют собственного `this`)

**Тест:**
```javascript
// ❌ Можно улучшить
array.map(function(item) {
  return item * 2;
});

// ✅ Предпочтительно
array.map(item => item * 2);

// ⚠️ Внимание: контекст this
const obj = {
  value: 10,
  // ❌ Неправильно - потеря контекста
  getValue: () => this.value,
  // ✅ Правильно
  getValue() {
    return this.value;
  }
};
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Предложить использование стрелочных функций где уместно, предупредить о контексте `this`.

---

#### 3.3 Деструктуризация
**Проверить:**
- Использование деструктуризации для объектов и массивов

**Тест:**
```javascript
// ❌ Можно улучшить
const name = user.name;
const age = user.age;
const first = array[0];

// ✅ Предпочтительно
const { name, age } = user;
const [first] = array;
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать места, где деструктуризация улучшит читаемость.

---

#### 3.4 Template literals
**Проверить:**
- Использование шаблонных строк вместо конкатенации

**Тест:**
```javascript
// ❌ Неправильно
const message = 'Hello, ' + name + '! You are ' + age + ' years old.';

// ✅ Правильно
const message = `Hello, ${name}! You are ${age} years old.`;
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать строки с конкатенацией и предложить использовать template literals.

---

### 4. АСИНХРОННЫЙ КОД

#### 4.1 Async/Await вместо коллбэков
**Проверить:**
- Использование `async/await` вместо вложенных коллбэков
- Избегание "callback hell"

**Тест:**
```javascript
// ❌ Неправильно (callback hell)
fs.readFile('file1.txt', (err, data1) => {
  if (err) throw err;
  fs.readFile('file2.txt', (err, data2) => {
    if (err) throw err;
    console.log(data1, data2);
  });
});

// ✅ Правильно
const fs = require('fs').promises;

async function readFiles() {
  try {
    const data1 = await fs.readFile('file1.txt');
    const data2 = await fs.readFile('file2.txt');
    console.log(data1, data2);
  } catch (err) {
    console.error(err);
  }
}
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на callback hell, объяснить преимущества async/await и предложить рефакторинг.

---

#### 4.2 Обработка ошибок в async функциях
**Проверить:**
- Все async функции обернуты в try-catch
- Promise.reject обрабатываются через .catch() или try-catch

**Тест:**
```javascript
// ❌ Неправильно - отсутствует обработка ошибок
async function fetchData() {
  const response = await fetch(url);
  return response.json();
}

// ✅ Правильно
async function fetchData() {
  try {
    const response = await fetch(url);
    return response.json();
  } catch (error) {
    console.error('Failed to fetch data:', error);
    throw error; // или обработать соответствующим образом
  }
}
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать async функции без обработки ошибок и предложить добавить try-catch.

---

#### 4.3 Избегание смешивания стилей
**Проверить:**
- Не смешиваются Promise и callback стили
- Не смешиваются async/await и .then()/.catch() в одной функции

**Тест:**
```javascript
// ❌ Неправильно - смешивание стилей
async function getData() {
  const result = await fetch(url).then(res => res.json());
  return result;
}

// ✅ Правильно
async function getData() {
  const response = await fetch(url);
  const result = await response.json();
  return result;
}
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать на смешивание стилей и предложить единообразный подход.

---

### 5. ОБРАБОТКА ОШИБОК

#### 5.1 Централизованная обработка ошибок
**Проверить:**
- Используется ли middleware для обработки ошибок (для Express)
- Ошибки не игнорируются молча

**Тест:**
```javascript
// ❌ Неправильно
try {
  riskyOperation();
} catch (err) {
  // пустой блок - игнорирование ошибки
}

// ✅ Правильно
try {
  riskyOperation();
} catch (err) {
  logger.error('Risky operation failed:', err);
  // обработка или пробрасывание
  throw err;
}

// ✅ Express middleware
app.use((err, req, res, next) => {
  logger.error(err.stack);
  res.status(500).send('Something went wrong!');
});
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на игнорируемые или неправильно обработанные ошибки.

---

#### 5.2 Кастомные классы ошибок
**Проверить:**
- Используются ли кастомные классы ошибок для разных типов ошибок

**Тест:**
```javascript
// ❌ Можно улучшить
throw new Error('User not found');

// ✅ Предпочтительно
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotFoundError';
    this.statusCode = 404;
  }
}

throw new NotFoundError('User not found');
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Предложить создание кастомных классов ошибок для улучшения типизации.

---

### 6. БЕЗОПАСНОСТЬ

#### 6.1 Чувствительные данные
**Проверить:**
- Нет хардкода паролей, API ключей, токенов
- Используются переменные окружения

**Тест:**
```javascript
// ❌ Критическая проблема безопасности
const API_KEY = 'sk-1234567890abcdef';
const dbPassword = 'myPassword123';

// ✅ Правильно
require('dotenv').config();
const API_KEY = process.env.API_KEY;
const dbPassword = process.env.DB_PASSWORD;
```

**Критичность:** Критичная  
**Действие при обнаружении:** Немедленно указать на проблему безопасности, потребовать переноса в .env файл.

---

#### 6.2 SQL инъекции и XSS
**Проверить:**
- Используются параметризованные запросы
- Входные данные валидируются и санитизируются

**Тест:**
```javascript
// ❌ SQL инъекция
const query = `SELECT * FROM users WHERE id = ${userId}`;

// ✅ Правильно (с параметризацией)
const query = 'SELECT * FROM users WHERE id = ?';
db.query(query, [userId]);

// ❌ XSS уязвимость
res.send(`<h1>Hello ${req.query.name}</h1>`);

// ✅ Правильно (с экранированием)
const escapeHtml = require('escape-html');
res.send(`<h1>Hello ${escapeHtml(req.query.name)}</h1>`);
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на уязвимость, объяснить риски и предложить безопасную альтернативу.

---

#### 6.3 Валидация входных данных
**Проверить:**
- Все входные данные проходят валидацию
- Используются библиотеки валидации (Joi, express-validator)

**Тест:**
```javascript
// ❌ Неправильно - отсутствует валидация
app.post('/user', (req, res) => {
  const user = req.body;
  db.save(user);
});

// ✅ Правильно
const Joi = require('joi');

const userSchema = Joi.object({
  name: Joi.string().min(3).required(),
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(0).max(120)
});

app.post('/user', (req, res) => {
  const { error, value } = userSchema.validate(req.body);
  if (error) {
    return res.status(400).json({ error: error.details[0].message });
  }
  db.save(value);
});
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на отсутствие валидации и предложить использовать библиотеку валидации.

---

### 7. ПРОИЗВОДИТЕЛЬНОСТЬ

#### 7.1 Блокирующие операции
**Проверить:**
- Не используются синхронные операции в production (fs.readFileSync)
- Используются асинхронные альтернативы

**Тест:**
```javascript
// ❌ Неправильно - блокирует event loop
const data = fs.readFileSync('file.txt', 'utf8');

// ✅ Правильно
const data = await fs.promises.readFile('file.txt', 'utf8');
// или
fs.readFile('file.txt', 'utf8', (err, data) => {
  // обработка
});
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на блокирующие операции и предложить асинхронные альтернативы.

---

#### 7.2 Утечки памяти
**Проверить:**
- Event listeners удаляются когда больше не нужны
- Таймеры и интервалы очищаются
- Нет глобальных переменных, которые постоянно растут

**Тест:**
```javascript
// ❌ Потенциальная утечка памяти
function setupListener() {
  eventEmitter.on('data', (data) => {
    // обработка
  });
}

// ✅ Правильно
function setupListener() {
  const handler = (data) => {
    // обработка
  };
  eventEmitter.on('data', handler);
  
  // Очистка
  return () => eventEmitter.off('data', handler);
}

const cleanup = setupListener();
// Позже: cleanup();
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать на потенциальные утечки памяти и предложить механизм очистки.

---

### 8. ТЕСТИРОВАНИЕ И ДОКУМЕНТАЦИЯ

#### 8.1 JSDoc комментарии
**Проверить:**
- Публичные функции имеют JSDoc комментарии
- Указаны типы параметров и возвращаемых значений

**Тест:**
```javascript
// ❌ Отсутствует документация
function calculateTotal(items, discount) {
  return items.reduce((sum, item) => sum + item.price, 0) * (1 - discount);
}

// ✅ Правильно
/**
 * Calculates the total price of items with discount applied
 * @param {Array<{price: number}>} items - Array of items with price property
 * @param {number} discount - Discount rate (0 to 1)
 * @returns {number} Total price after discount
 * @throws {TypeError} If items is not an array
 */
function calculateTotal(items, discount) {
  if (!Array.isArray(items)) {
    throw new TypeError('Items must be an array');
  }
  return items.reduce((sum, item) => sum + item.price, 0) * (1 - discount);
}
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Предложить добавить JSDoc для публичных функций.

---

#### 8.2 Комментарии в коде
**Проверить:**
- Комментарии объясняют "почему", а не "что"
- Нет закомментированного кода (dead code)
- Комментарии актуальны

**Тест:**
```javascript
// ❌ Бесполезный комментарий
// Увеличиваем counter на 1
counter++;

// ❌ Закомментированный код
// const oldFunction = () => {
//   // старая логика
// };

// ✅ Полезный комментарий
// Используем debounce для предотвращения множественных вызовов API
// при быстром вводе пользователя
const debouncedSearch = debounce(searchAPI, 300);
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать на бесполезные комментарии или мертвый код, предложить удаление.

---

### 9. ФОРМАТИРОВАНИЕ И СТИЛЬ

#### 9.1 Отступы и пробелы
**Проверить:**
- Единообразные отступы (2 или 4 пробела)
- Отсутствие табов и пробелов вперемешку
- Пробелы вокруг операторов

**Тест:**
```javascript
// ❌ Неправильно
function test(){
const x=1+2;
  if(x>0){
return x;
  }
}

// ✅ Правильно
function test() {
  const x = 1 + 2;
  if (x > 0) {
    return x;
  }
}
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать на проблемы форматирования, предложить использовать Prettier.

---

#### 9.2 Точка с запятой
**Проверить:**
- Единообразное использование точек с запятой (либо везде, либо нигде, но консистентно)

**Тест:**
```javascript
// ❌ Неконсистентно
const a = 1;
const b = 2
const c = 3;

// ✅ Консистентно (со точками с запятой)
const a = 1;
const b = 2;
const c = 3;

// ✅ Консистентно (без точек с запятой, но требует понимания ASI)
const a = 1
const b = 2
const c = 3
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать на несоответствие и предложить выбрать единый стиль.

---

#### 9.3 Длина строки
**Проверить:**
- Строки не превышают 80-120 символов
- Длинные выражения разбиты на несколько строк

**Тест:**
```javascript
// ❌ Слишком длинная строка
const result = someVeryLongFunctionName(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6);

// ✅ Правильно
const result = someVeryLongFunctionName(
  parameter1,
  parameter2,
  parameter3,
  parameter4,
  parameter5,
  parameter6
);
```

**Критичность:** Рекомендация  
**Действие при обнаружении:** Указать на длинные строки и предложить разбиение.

---

### 10. NODE.JS СПЕЦИФИКА

#### 10.1 Версия Node.js
**Проверить:**
- Указана версия Node.js в package.json (engines field)
- Используются фичи, совместимые с указанной версией

**Тест:**
```json
// ✅ Правильно в package.json
{
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
```

**Критичность:** Важная  
**Действие при обнаружении:** Предложить добавить поле engines в package.json.

---

#### 10.2 Обработка process событий
**Проверить:**
- Обработчики для uncaughtException и unhandledRejection
- Graceful shutdown при SIGTERM/SIGINT

**Тест:**
```javascript
// ✅ Правильно
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing server gracefully');
  await server.close();
  process.exit(0);
});
```

**Критичность:** Критичная  
**Действие при обнаружении:** Указать на отсутствие обработчиков и предложить их добавление.

---

#### 10.3 Использование path модуля
**Проверить:**
- Используется модуль `path` для работы с путями (кросс-платформенность)
- Не используются хардкод пути с `/` или `\`

**Тест:**
```javascript
// ❌ Неправильно - не кросс-платформенно
const filePath = __dirname + '/files/data.json';
const filePath2 = __dirname + '\\files\\data.json';

// ✅ Правильно
const path = require('path');
const filePath = path.join(__dirname, 'files', 'data.json');
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать на хардкод путей и предложить использовать модуль path.

---

#### 10.4 __dirname и __filename в ES modules
**Проверить:**
- При использовании ES modules правильно получать __dirname и __filename

**Тест:**
```javascript
// ❌ Неправильно в ES modules
import fs from 'fs';
// __dirname недоступен напрямую

// ✅ Правильно в ES modules
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

**Критичность:** Критичная (если используются ES modules)  
**Действие при обнаружении:** Указать на ошибку и предложить правильный способ получения __dirname.

---

### 11. ЗАВИСИМОСТИ

#### 11.1 package.json
**Проверить:**
- Версии зависимостей указаны явно (не `*` или `latest`)
- dependencies и devDependencies правильно разделены
- Нет неиспользуемых зависимостей

**Тест:**
```json
// ❌ Неправильно
{
  "dependencies": {
    "express": "*",
    "lodash": "latest"
  }
}

// ✅ Правильно
{
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "eslint": "^8.38.0"
  }
}
```

**Критичность:** Важная  
**Действие при обнаружении:** Указать на проблемы с версиями и предложить использовать конкретные версии.

---

#### 11.2 Устаревшие зависимости
**Проверить:**
- Зависимости не сильно устарели
- Нет зависимостей с известными уязвимостями

**Критичность:** Важная  
**Действие при обнаружении:** Предложить проверить зависимости командой `npm audit` и обновить при необходимости.

---

## ПРОЦЕСС ПРОВЕРКИ

### Шаг 1: Предварительный анализ
1. Определить тип проекта (API, CLI tool, библиотека)
2. Проверить наличие package.json, .eslintrc, .prettierrc
3. Определить используемый стиль модулей (CommonJS или ES6)

### Шаг 2: Анализ кода
Последовательно проверить код по всем разделам выше, группируя найденные проблемы по критичности:
- **Критичные**: Безопасность, ошибки, производительность
- **Важные**: Структура, обработка ошибок, Node.js специфика
- **Рекомендации**: Стиль, форматирование, документация

### Шаг 3: Формирование отчета
Создать структурированный отчет в следующем формате:

```
# Отчет о проверке кода

## Общая информация
- Проверено файлов: [число]
- Найдено проблем: [число]
  - Критичных: [число]
  - Важных: [число]
  - Рекомендаций: [число]

## Критичные проблемы (требуют немедленного исправления)

### 1. [Название проблемы]
**Файл:** [путь к файлу:строка]
**Проблема:** [описание]
**Риск:** [объяснение почему это критично]
**Текущий код:**
```javascript
[проблемный код]
```
**Предлагаемое исправление:**
```javascript
[исправленный код]
```

## Важные проблемы

[аналогичная структура]

## Рекомендации

[аналогичная структура]

## Положительные моменты

[что сделано хорошо]

## Вопросы к разработчику

1. [Вопрос о неясных моментах, требующих уточнения]
2. ...

## Следующие шаги

Рекомендуется исправить проблемы в следующем порядке:
1. [приоритизированный список]
2. ...

Желаете ли вы, чтобы я внес эти исправления? 
Пожалуйста, укажите какие проблемы следует исправить.
```

### Шаг 4: Взаимодействие с пользователем
После предоставления отчета:
1. **Ждать явного согласия** пользователя на внесение изменений
2. Если пользователь согласен - уточнить какие именно проблемы исправить
3. Вносить изменения только после получения согласия
4. После каждого изменения показывать что именно было изменено

### Шаг 5: Предложение инструментов
Рекомендовать настройку автоматических инструментов:
- **ESLint** - для автоматической проверки кода
- **Prettier** - для форматирования
- **Husky** - для pre-commit hooks
- **lint-staged** - для проверки только измененных файлов

---

## ПРИМЕРЫ ОТВЕТОВ

### Пример 1: Обнаружены критичные проблемы

```
Я проанализировал ваш код и обнаружил несколько проблем, требующих внимания.

## 🔴 Критичная проблема безопасности

**Файл:** `server.js:15`
**Проблема:** API ключ захардкоден в коде

Текущий код:
```javascript
const API_KEY = 'sk-abc123def456';
```

Это серьезная проблема безопасности. API ключи не должны храниться в исходном коде.

**Рекомендуемое решение:**
1. Создать файл `.env`:
```
API_KEY=sk-abc123def456
```

2. Добавить `.env` в `.gitignore`

3. Изменить код:
```javascript
require('dotenv').config();
const API_KEY = process.env.API_KEY;
```

Могу ли я внести это исправление?
```

### Пример 2: Множественные проблемы разной критичности

```
Анализ завершен. Найдено 12 проблем:
- 2 критичных
- 5 важных
- 5 рекомендаций

Начну с критичных проблем...

[детальный отчет]

Какие проблемы вы хотите исправить в первую очередь? 
Рекомендую начать с критичных проблем безопасности.
```

### Пример 3: Код в хорошем состоянии

```
Отлично! Ваш код в целом соответствует стандартам Node.js.

Найдено только несколько незначительных рекомендаций:

1. Можно добавить JSDoc комментарии к публичным функциям
2. Рекомендуется использовать более строгие версии зависимостей в package.json

Хотите ли вы, чтобы я внес эти улучшения?
```

---

## ВАЖНЫЕ НАПОМИНАНИЯ ДЛЯ ИИ

1. ❌ **НИКОГДА** не вносить изменения без явного согласия пользователя
2. ✅ **ВСЕГДА** объяснять почему что-то является проблемой
3. ✅ **ВСЕГДА** показывать конкретные примеры исправлений
4. ✅ **ВСЕГДА** приоритизировать проблемы по критичности
5. ✅ **ВСЕГДА** быть конструктивным и помогающим, не критичным
6. ✅ **ВСЕГДА** спрашивать если что-то неясно в коде
7. ❌ **НИКОГДА** не делать предположений о бизнес-логике
8. ✅ **ВСЕГДА** отмечать положительные моменты в коде

---

## ЗАВЕРШЕНИЕ ПРОВЕРКИ

После проверки кода:
1. Подвести итоги проверки
2. Указать общую оценку качества кода (отличное/хорошее/требует улучшений/критичное)
3. Дать общие рекомендации по улучшению процесса разработки
4. Предложить настройку инструментов для автоматизации проверок
5. Ответить на вопросы разработчика

---

## КОНЕЦ ИНСТРУКЦИИ

